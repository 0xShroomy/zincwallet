Light Client Development
The following resources allow development of apps and services that can transact on the blockchain without downloading an entire copy of the blockchain. A light client (also known as lightweight node) is referencing a trusted full node’s copy of the blockchain, whereas a full node is a node that fully enforces all of the rules of the blockchain.

../_images/shielded-support.png
Lightwalletd
A stateless server that serves light clients with blockchain information. It fetches blockchain data from zcashd, processes them to reduce data, and stores it in a database. This allows light clients with different requirements to get relevant data without interacting with zcashd directly.

Resources

Lightwalletd source code

Lightwalletd instance setup guide

Lightwalletd API docs

Quick info

Parallelize-able, stateless, and containerized

Can run virtually on the cloud (EC2, GCP, AZURE, Docker, etc.)

Not using load balancers, orchestrators, schedulers (yet)

Metrics, stress tests, and testing done (ask us)

Android
We maintain a SDK that allows for wallet functionalities (address management, send, receive, etc.), documentation of the APIs, and a demo app that exercises the SDK.

Resources

Android SDK source code

Android Demo app

Android API docs

Quick info

Native Android SDK and app, written in Kotlin

Architecture: targeting ARM64, ARMv7 and x86

APIs: We support API 16+ but we optimize for API versions 21+

iOS
We maintain a SDK that allows for wallet functionalities (address management, send, receive, etc.), documentation of the APIs, and a demo app that exercises the SDK.

Resources

iOS SDK source code

iOS Demo app

iOS API docs

Quick info

Native iOS SDK and app, written in Swift

Less mature then Android SDK but working towards parity

Targeting the latest (past two 2 years) iPhones

WASM
A minimal functioning demo web wallet that allows desktop OSes to use shielded addresses and separates web-specific wallet functionalities.

Originally built 2019, and is not actively maintained: https://github.com/str4d/zcon1-demo-wasm.

References
Light client threat model

Contributing guidelines









Wallet App Threat Model
This threat model is intended for curious technical users of the ECC wallet apps as well as developers making use of the SDK in their own apps. The threat model applies to the internal ECC reference wallet, and should apply to any Zcash wallet built on top of the ECC SDKs, unless significant modifications have been made. See the Invariant-Centric Threat Modeling for a complete explanation of the threat modeling methodology we use. Here’s a short summary of the methodology:

This document lists “security invariants” that the apps and SDK should currently provide. Users and developers should not rely on any security or privacy properties that are not explicitly listed here. If there’s a security or privacy property that you would like to be able to rely on, but isn’t listed here, then please raise an issue on GitHub.

We aim to state security invariants in a language that end-users would understand. If a security invariant uses technical language or involves complicated concepts then users are unlikely to understand it, which could lead to them being overconfident in their use of the software.

If you are a security auditor, please try to break one of the security invariants or think about which important security invariants might be missing from this list!

The security properties that the apps and SDKs provide depend on how powerful the adversary trying to attack the user is. This threat model’s security invariants are organized into sections for each kind of adversary. We start with the most powerful kind of adversary, one who has completely compromised the lightwalletd server the wallet connects to, can intercept network traffic, install apps on the user’s phone, etc., and end with the weakest kind of adversary, one who simply knows the user’s address and can observe the public blockchain. In order to simplify this document, we assume that the stronger adversaries have all of the capabilities of the weaker adversaries. For each kind of adversary, we list:

Which security invariants we expect are satisfied against that adversary (and all weaker ones). If one of these are false, then it’s a security bug. If a user is relying on a security invariant that’s not in the threat model, then that’s also considered a security bug.

Known weaknesses: Which security invariants we know are not satisfied against that adversary (and all stronger ones). If a user does not understand one of these weaknesses, then that is a security problem in the app’s UX/documentation. We include brief technical details of each weakness.

There are several weaknesses that we believe most users would find counter-intuitive, or at least not expect to be the case based on their experience using other cryptocurrency wallets or zcashd. We’ve highlighted those ones in bold.

Let’s begin with the most powerful kind of adversary considered by our model.

Lightwalletd-Compromising Adversary
Description: The lightwalletd service the user connects to is compromised or outright malicious. In addition to being in complete control over lightwalletd, the adversary can intercept all of the app’s network traffic and can run code as another app on the user’s phone (e.g. a fake calculator app). The adversary knows some addresses belonging to the user. Accidental reorgs happen regularly.

We expect the following security invariants to be satisfied when the user is attacked by this kind of adversary as well as any of the weaker ones in the sections below. The adversary…

can’t execute arbitrary code on the user’s phone.

can’t learn any of the user’s cryptographic key material (spending keys, viewing keys, seed phrase, etc.)

can’t steal the user’s funds.

can’t make the user send funds when they did not intend to.

can’t burn the user’s funds or otherwise make them unspendable.

can’t cause the funds the user sends to someone else to be gone from their wallet but be unspendable by the recipient.

can’t make the funds go to someone else when someone was trying to send the user funds.

can’t make the user send funds to the wrong address.

can’t tell what the user’s current shielded balance is (aside from it being zero when the wallet is created).

can’t learn information about the value, memo field, etc. of shielded transactions the user receives.

can’t learn information about the value, memo field, etc. of shielded transactions the user sends.

can’t learn who the user is sending/receiving funds to/from in fully-shielded transactions as long as the other user isn’t using the same lightwalletd service provider and there is no collusion between the adversary and that other service provider.

This is not a useful security invariant, because it is hard for users to understand.

can’t learn information about the user’s shielded balance over time (aside from the assumption that it must be nonzero after they’ve received transactions).

can’t make the user think person X has sent them funds when it was actually someone different.

can’t find out one of the user’s wallet addresses unless the user has given it out or the adversary has a guess for what it is.

Note that this adversary can check whether an address they have belongs to the user, see the weaknesses in the sections below.

can’t send money to the user at any address of theirs that the adversary did not already know about.

can’t cause a transaction the user is receiving to fail on the Zcash network.

can’t make the user send the wrong amount of funds.

can’t make the user send a transaction with a memo field they did not intend.

can’t make it look like a payment the user received came from someone who it actually did not.

can’t make it look (to someone else) like the user is sending funds to somewhere they are not.

can’t make it look (to someone else) like the user is receiving money from somewhere that they are not.

can’t cause the app to display a false official-looking message.

can’t see any of the user’s wallet history when they connect to this lightwalled instance for the first time (after previously using a different one).

can’t make the wallet display transaction information where part of it comes from one transaction and another part of it comes from another transaction (such displaying the memo field from one transaction with the value of another transaction).

There are some known weaknesses this adversary can exploit. In addition to all of the known weaknesses from the sections below (which also apply to this adversary, because this one is capable of all the same things and more), the adversary can…

make the user think they have (or will have) spendable funds when they don’t.

They can repeat a transaction to the user’s wallet many times to cause the wallet to think it has more balance than it can actually spend.

make the user think their balance is lower than it actually is.

They can omit transactions destined to user, so that the user’s wallet can have spendable funds that it isn’t aware of.

make the user think a transaction they sent or received succeeded when it actually failed.

If the transaction gets reorged-away or never mined, the adversary could make it look like it was actually mined.

make the user think a transaction they sent or received failed when it actually succeeded.

They could omit the transaction, making it look like it failed when in fact it was mined on the Zcash network.

We plan to eventually fix these issues by implementing the block header and note commitment tree validation specified in ZIP 307.

Let’s move on to the second-most powerful kind of adversary we will consider.

Typical Adversary
Description: There is a trust relationship between the user and the lightwalletd server operator. Lightwalletd only ever provides valid information coming from a consistent Zcash blockchain state. The information is not guaranteed to be recent, and part of it may change (e.g. after a reorg) and even revert to old state. The connection to lightwallletd is protected by TLS, which we assume to be secure. The adversary (a) can intercept all of the app’s network traffic, (b) can run code as an app on the user’s phone (e.g. fake calculator app), and (c) can read (but not write to) the lightwalletd server’s private memory. The adversary knows some addresses belonging to the user. Accidental reorgs happen regularly. NB: If the lightwalletd server gets compromised temporarily, which we should assume will eventually happen, the security properties degrade to the Lightwalletd-Compromising Adversary for the duration of the compromise, and possibly longer if the effects of the attack persist.

We expect the following security invariants to be satisfied when the user is attacked by this kind of adversary as well as any of the weaker ones in the sections below. The adversary…

can’t make the user think their balance is lower than it actually is.

can’t make the user think they have (or will have) spendable funds when they don’t.

can’t make the user think a transaction they sent or received succeeded when it actually failed.

can’t make the user think a transaction they sent or received failed when it actually succeeded.

There are no known weaknesses that apply to this adversary specifically. All of the known weaknesses in the sections below for weaker adversaries apply to this adversary as well.

Network- and Lightwalletd-Surveiling Adjacent-App Adversary
Description: The adversary can only (a) intercept all network traffic between the app and the internet, (b) can run code as an app on the user’s phone (e.g. fake calculator app), and (c) intercept the traffic between the lightwalletd server and the Internet. The adversary knows some addresses belonging to the user. Accidental reorgs happen regularly. We assume defenses are in place to detect eclipsing of the lightwalletd node.

There are no security invariants that we expect to be satisfied specifically for this adversary but not the one discussed in the previous section.

There are several known weaknesses that this kind of adversary can exploit. The adversary can…

tell that and when the user received a fully-shielded transaction.

The wallet fetches the memo from lightwalletd separately, which uses more bandwidth, and that is visible even though the connection is encrypted.

If the bandwidth side channels are fixed, the act of sending and receiving transactions is visible to the lightwalletd server, so this would become a known weakness in the Typical scenario.

tell that and when the user sends a fully-shielded transaction.

The act of sending a transaction uses more bandwidth, which is visible even though the connection is encrypted.

If the bandwidth side channels are fixed, the act of sending and receiving transactions is visible to the lightwalletd server, so this would become a known weakness in the Typical scenario.

learn who the user is sending/receiving funds to/from in fully-shielded transactions.

When both users are using the same lightwalletd instance, even though the connections are encrypted, the adversary will be able to correlate bandwidth spikes that look like sends from one user with bandwidth spikes that look like receives from another user.

If the bandwidth side channels are fixed, the act of sending and receiving transactions is visible to the lightwalletd server, so this would become a known weakness in the Typical scenario.

tell how many transactions the user has sent or received over time.

For the same reasons as above.

determine whether or not the user’s wallet owns a particular address.

The adversary could send funds to that address and watch to see if there are bandwidth spikes that look like the wallet fetched a memo around the same time.

If the bandwidth side channels are fixed, the act of receiving a transaction is still visible to the lightwalletd server so this would become a known weakness in the Typical scenario.

tell who the user is.

The adversary knows the user’s IP address, which could lead them to the user’s real identity.

tell where the user is.

The adversary could look up the user’s IP address in a geolocation database to approximate their location.

tell that the user spends or receives money according to a certain pattern (e.g. recurring payments) using fully-shielded transactions.

They would observe bandwidth spikes that look like sends/receives following the same pattern.

make the user think outdated information (transactions, balance, etc.) is up to date.

By blocking the connection to lightwalletd.

tell which of many users of the lightwalletd instance the user is.

If the user reconnects from the same IP address, they can usually assume it is the same user.

silently prevent the user from receiving wallet security updates or security notices

By blocking the phone’s connection to the internet or app store.

tell which cryptocurrencies the user is using if the SDK is used in a multi-currency wallet.

The adversary would be able to see that the wallet is connecting to a lightwalletd instance, which reveals they are using the Zcash component of the wallet.

tell when the user is actively using the wallet.

They can see that the wallet is communicating with lightwalletd when it’s in active use.

tell when the user’s wallet was created.

The wallet only downloads blocks starting with the last checkpoint before its birthday. By observing how much bandwidth gets used during the initial download, the adversary can determine approximately how many blocks it downloaded, and thus approximately what its birthday is.

cause a transaction the user sends to fail.

They can block the connection between the wallet and lightwalletd.

These weaknesses also apply to the stronger adversaries in the sections above.

Let’s move on to the weakest adversary considered in this model.

Address-Knowing Adversary
Description: The adversary only knows some of the users’ z-addresses and t-addresses, can view the public blockchain, and has no other special capabilities.

This is the weakest adversary in our model. The security invariants we expect to be satisfied against this adversary are that the adversary…

can’t tell that or when the user has received a fully-shielded transaction.

can’t tell that or when the user sends a fully-shielded transaction.

can’t learn who the user is sending/receiving funds to/from in fully-shielded transactions.

can’t tell how many transactions the user has sent or received over time.

can’t determine whether or not the user’s wallet owns a particular address.

can’t tell who the user is (i.e. their real name).

can’t tell where the user is.

can’t tell that the user spends money according to a certain pattern (e.g. recurring payments) using fully-shielded transactions.

can’t make the user think outdated information (transactions, balance, etc.) is up to date.

can’t tell which of the many users of the lightwalletd instance the user is.

can’t silently prevent the user from receiving wallet security updates or security notices.

can’t tell which cryptocurrencies the user is using if the SDK is in use in a multi-currency wallet.

can’t tell when the user is actively using the wallet.

can’t tell when the user’s wallet was created.

can’t cause a transaction the user sends to fail.

There are several known weaknesses that this adversary can exploit. The adversary can…

tell when the user spends shielded funds sent to them by the adversary.

dust attack: the adversary can send many low-value notes, which will be spent in a transaction with many Sapling inputs (visible on the blockchain).

The fix for this issue is to implement note merging, so that dust notes are combined into one by the user’s wallet in the background.

tell when the user sends or receives a t-address transaction, and tell what their transparent balance is.

t-address are not private, users should use fully shielded transactions to obtain privacy.

tell that the user is using this particular wallet app.

differences in note selection might distinguish it from zcashd.

These weaknesses also apply to all of the stronger adversaries in the sections above.

Limitations
This threat model is missing important details, for example, about:

Adversaries that have physical access to the device the app or SDK is running on.

Secure usability of the SDK’s API.

Implicit assumptions about how the SDK is being used in a third-party app.

More fine-grained models of adversaries, e.g. one that has eclipsed the lightwalletd node but has not been able to compromise it fully.

These shortcomings will be addressed in future updates to the threat model.




Lightwalletd Instance Setup Guide
There are several reasons you may want to set up your own lightwalletd instance rather than using one of the public instances.

while developing your light client (wallet) code, you can see lightwalletd’s logging output

for production use with your own light clients, to minimize trust by controlling this important part of the infrastructure

to contribute to the development of lightwalletd itself.

There are two ways to deploy a lightwalletd instance:

Clone the lightwalletd source code from its GitHub repo

Run a binary instance using Docker. The Docker host networking driver only works on Linux hosts, so we do not recommend this option for Mac or Windows.

This rest of this guide helps with the second option, which is the easier of the two. You will need root (sudo) permissions. Install these if you haven’t already:

Zcashd

Docker

Start zcashd on either testnet or mainnet and wait for it to finish syncing with the network.

The lightwalletd maintains some on-disk state (database) that must persist across restarts. Create a directory to contain this state; you can choose any name (adjust below) but it needs this particular user ID, 2002, as its owner:

mkdir ./lightwalletd_db_volume
sudo chown 2002 ./lightwalletd_db_volume
Last step! Launch lightwalletd, port 8232 is mainnet; 18232 is testnet; also substitute your zcashd’s rpcuser and rpcpassword:

docker run --rm \
  --volume $PWD/lightwalletd_db_volume:/srv/lightwalletd/db_volume \
  --network host \
  electriccoinco/lightwalletd:v0.4.2 \
  --grpc-bind-addr 0.0.0.0:9067 \
  --no-tls-very-insecure \
  --rpchost localhost \
  --rpcport 8232 \
  --rpcuser lightwd \
  --rpcpassword lightpassword \
  --data-dir /srv/lightwalletd/db_volume \
  --log-file /dev/stdout
The first time you run this, you’ll see logging that shows lightwalletd downloading blocks from zcashd The lightwalletd is usable immediately; the blocks downloading improves performance (once it completes). You’ll see two files populating within the database directory. After it has download the blocks, then when you start lightwalletd it will have high performance immediately.

If you remove the database directory (do that only while lightwalletd isn’t running), it will re-download blocks the next time it runs. This database is simply a cache and never contains critical data.

If you restart zcashd to the other network (testnet to mainnet or the reverse), you must restart lightwalletd. But you can restart zcashd to the same network without restarting lightwalletd; it will attempt to reconnect for a few minutes and then give up.

You can test that it’s running correctly using the grpcurl tool, for example:

$ grpcurl -plaintext localhost:9067 cash.z.wallet.sdk.rpc.CompactTxStreamer/GetLightdInfo
  "version": "v0.4.2",
  "vendor": "ECC LightWalletD",
  "taddrSupport": true,
  "chainName": "main",
  "saplingActivationHeight": "419200",
  "consensusBranchId": "f5b9230b",
  "blockHeight": "948288"
}
$ 






lighthouse api docs:
Protocol Documentation
Table of Contents
compact_formats.proto
MCompactBlock
MCompactOutput
MCompactSpend
MCompactTx
service.proto
MBlockID
MBlockRange
MChainSpec
MDuration
MEmpty
MLightdInfo
MPingResponse
MRawTransaction
MSendResponse
MTransparentAddressBlockFilter
MTxFilter
SCompactTxStreamer
Scalar Value Types
compact_formats.proto	Top
CompactBlock
CompactBlock is a packaging of ONLY the data from a block that's needed to:

1. Detect a payment to your shielded Sapling address

2. Detect a spend of your shielded Sapling notes

3. Update your witnesses to generate new Sapling spend proofs.

Field	Type	Label	Description
protoVersion	uint32		
the version of this wire format, for storage

height	uint64		
the height of this block

hash	bytes		

prevHash	bytes		

time	uint32		

header	bytes		
(hash, prevHash, and time) OR (full header)

vtx	CompactTx	repeated	
compact transactions from this block

CompactOutput
Field	Type	Label	Description
cmu	bytes		

epk	bytes		

ciphertext	bytes		

CompactSpend
Field	Type	Label	Description
nf	bytes		

CompactTx
Index and hash will allow the receiver to call out to chain

explorers or other data structures to retrieve more information

about this transaction.

Field	Type	Label	Description
index	uint64		

hash	bytes		

fee	uint32		
The transaction fee: present if server can provide. In the case of a stateless server and a transaction with transparent inputs, this will be unset because the calculation requires reference to prior transactions. in a pure-Sapling context, the fee will be calculable as: valueBalance + (sum(vPubNew) - sum(vPubOld) - sum(tOut))

spends	CompactSpend	repeated	

outputs	CompactOutput	repeated	

service.proto	Top
BlockID
A BlockID message contains identifiers to select a block: a height or a

hash. Specification by hash is not implemented, but may be in the future.

Field	Type	Label	Description
height	uint64		

hash	bytes		

BlockRange
BlockRange specifies a series of blocks from start to end inclusive.

Both BlockIDs must be heights; specification by hash is not yet supported.

Field	Type	Label	Description
start	BlockID		

end	BlockID		

ChainSpec
Chainspec is a placeholder to allow specification of a particular chain fork.

Duration
Duration is currently used only for testing, so that the Ping rpc

can simulate a delay, to create many simultaneous connections. Units

are microseconds.

Field	Type	Label	Description
intervalUs	int64		

Empty
Empty is for gRPCs that take no arguments, currently only GetLightdInfo.

LightdInfo
LightdInfo returns various information about this lightwalletd instance

and the state of the blockchain.

Field	Type	Label	Description
version	string		

vendor	string		

taddrSupport	bool		

chainName	string		

saplingActivationHeight	uint64		

consensusBranchId	string		

blockHeight	uint64		

PingResponse
PingResponse is used to indicate concurrency, how many Ping rpcs

are executing upon entry and upon exit (after the delay).

Field	Type	Label	Description
entry	int64		

exit	int64		

RawTransaction
RawTransaction contains the complete transaction data. It also optionally includes

the block height in which the transaction was included

Field	Type	Label	Description
data	bytes		

height	uint64		

SendResponse
A SendResponse encodes an error code and a string. It is currently used

only by SendTransaction(). If error code is zero, the operation was

successful; if non-zero, it and the message specify the failure.

Field	Type	Label	Description
errorCode	int32		

errorMessage	string		

TransparentAddressBlockFilter
TransparentAddressBlockFilter restricts the results to the given address

or block range.

Field	Type	Label	Description
address	string		

range	BlockRange		

TxFilter
A TxFilter contains the information needed to identify a particular

transaction: either a block and an index, or a direct transaction hash.

Currently, only specification by hash is supported.

Field	Type	Label	Description
block	BlockID		

index	uint64		

hash	bytes		

CompactTxStreamer
Method Name	Request Type	Response Type	Description
GetLatestBlock	ChainSpec	BlockID	
Compact Blocks

GetBlock	BlockID	CompactBlock	
GetBlockRange	BlockRange	CompactBlock stream	
GetTransaction	TxFilter	RawTransaction	
Transactions

SendTransaction	RawTransaction	SendResponse	
GetAddressTxids	TransparentAddressBlockFilter	RawTransaction stream	
t-Address support

GetLightdInfo	Empty	LightdInfo	
Misc

Ping	Duration	PingResponse	
Scalar Value Types
.proto Type	Notes	C++ Type	Java Type	Python Type
double		double	double	float
float		float	float	float
int32	Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.	int32	int	int
int64	Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.	int64	long	int/long
uint32	Uses variable-length encoding.	uint32	int	int/long
uint64	Uses variable-length encoding.	uint64	long	int/long
sint32	Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.	int32	int	int
sint64	Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.	int64	long	int/long
fixed32	Always four bytes. More efficient than uint32 if values are often greater than 2^28.	uint32	int	int
fixed64	Always eight bytes. More efficient than uint64 if values are often greater than 2^56.	uint64	long	int/long
sfixed32	Always four bytes.	int32	int	int
sfixed64	Always eight bytes.	int64	long	int/long
bool		bool	boolean	boolean
string	A string must always contain UTF-8 encoded or 7-bit ASCII text.	string	String	str/unicode
bytes	May contain any arbitrary sequence of bytes.	string	ByteString	str
Read the Docs
 latest
EthicalAds is a GDPR-compliant ad network for devs No cookie banners, and only dev-focused ads.
